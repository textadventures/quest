<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Pattern Matching with Regular Expressions</title>
    <link rel="stylesheet" href="bootstrap.min.css">
    <link rel="stylesheet" href="docs.css">
    <script src="http://code.jquery.com/jquery-1.11.1.min.js"></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>
    <div class="navbar navbar-inverse" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html">Quest Documentation</a>
        </div>
        <div class="collapse navbar-collapse">
          <ul class="nav navbar-nav">
            <li ><a href="index.html">Home</a></li>
            <li ><a href="tutorial/index.html">Tutorial</a></li>
            <li ><a href="http://docs.textadventures.co.uk/quest/scripts/">Scripts</a></li>
            <li ><a href="functions/index.html">Functions</a></li>
            <li ><a href="attributes.html">Attributes</a></li>
            <li><a href="http://textadventures.co.uk/forum">Forum</a></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="container">
      <h1>Pattern Matching with Regular Expressions</h1>
      <p>What exactly is a “regular expression”? It is a sort of string that can be used to match against another string. You could think of it as a template or a set of rules that a string can be compared to. Quest handles a regex as a string, but behind the scenes it converts that into a proper regex object deep in its workings.</p>

<p>Quest has three functions that can use a regex. All three functions takes the regex and a string to compare against it as parameters and differ only in what they return.</p>

<p>To investigate what the three functions do, I am going to set up a regex and two strings.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regex = "put (?&lt;object1&gt;.*) on (?&lt;object2&gt;.*)"
s1 = "put hat on table"
s2 = "put hat in box"
</code></pre></div></div>

<h2 id="the-regex">The Regex</h2>

<p>So what does that regex mean? We will look at this in detail later, but the regex for a lot of commands use these same components, so we will quickly look at it now. The two bits in brackets, <code class="highlighter-rouge">(?&lt;object1&gt;.*)</code>, are called “capture groups”, that is, groups of characters that we want to capture for later use. The capture group starts with an open bracket, followed by a question mark, and then the name of the group in angle brackets, <code class="highlighter-rouge">&lt;object1&gt;</code>, followed by the pattern to match, <code class="highlighter-rouge">.*</code>, which in this case says to match any number of anything, and then ended with a close bracket.</p>

<p>The rest of the regex is simple text and this needs to match exactly.</p>

<h2 id="isregexmatch"><code class="highlighter-rouge">IsRegexMatch</code></h2>

<p>The <code class="highlighter-rouge">IsRegexMatch</code> function will return true if there is a match and false if not. For our example, the first string is a match, the words (and spaces) of “put” and “on” match exactly, and hat and table match the capture groups. The second return false, because “in” does not match “on”.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IsRegexMatch(regex, s1)
=&gt; true
IsRegexMatch(regex, s2)
=&gt; false
</code></pre></div></div>

<h2 id="getmatchstrength"><code class="highlighter-rouge">GetMatchStrength</code></h2>

<p>The <code class="highlighter-rouge">GetMatchStrength</code> will return an indication of how good the match is, or throw an error if it is not a match. The strength is simply the number of characters that are matched outside of the capture groups. For <code class="highlighter-rouge">s1</code>, these are “put “ and “ on “, a total of eight characters.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GetMatchStrength(regex, s1)
=&gt; 8
GetMatchStrength(regex, s2)
=&gt; Error running script: Error evaluating expression ...
</code></pre></div></div>

<h2 id="populate"><code class="highlighter-rouge">Populate</code></h2>

<p>The <code class="highlighter-rouge">Populate</code> function will return a dictionary containing the capture groups, or throw an error if it is not a match. Each entry in the dictionary will have the name of the capture group paired with the matched text.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Populate(regex, s1)
=&gt; Dictionary: object1 = hat;object2 = table
Populate(regex, s2)
=&gt; Error running script: Error evaluating expression ...
</code></pre></div></div>

<h2 id="the-cache-id-parameter">The “cache ID” parameter</h2>

<p>All the above functions take an optional third parameter, the “cache ID”. If you supply a cache ID, the regex will be saved under that name. The next time you use that cache ID for any of the above functions, Quest will ignore the regex you supply, and use the one it created earlier instead.</p>

<p>Continuing with the example before:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>IsRegexMatch(regex, s1, "my regex")
=&gt; true
IsRegexMatch("nonsense", s1, "my regex")
=&gt; true
</code></pre></div></div>
<p>The original regex is given a cache ID here (the string “my regex”). When <code class="highlighter-rouge">IsRegexMatch</code> is called a second time, Quest ignores the nonsense regex, because it already has a regex with that cache ID.</p>

<p>Every time the player types some input, Quest has to compare that against the regex for every command, and using cache IDs makes that process considerably faster (and it does that for any custom command you add yourself). It is doubtful if cache IDs are of significant use outside of that, and are more likely to be a source of obscure bugs, so my advice is to not use them.</p>

<h2 id="command-matching">Command Matching</h2>

<p>When the player types some input, Quest goes through the list of commands, looking for the best match. A match is determined by using <code class="highlighter-rouge">IsRegexMatch</code>.</p>

<p>If there are more than one matching commands, quest uses three criteria to select the best. Firstly it looks at the value from <code class="highlighter-rouge">GetMatchStrength</code>, giving priority to the command with the higher match strength.</p>

<p>If there is a tie for the highest match strength, it will give priority to the command specific to the room. If there is still a tie after that, commands lower down the list take priority (so user defined commands take priority over the built in commands).</p>

<p>Note that verb objects are actually a type of command, so when the game iterates through all the commands, that includes verbs. A verb object is really just a command with some specific behaviour, which is to run a certain script on the given object.</p>

<h2 id="a-note-about-patterns">A Note About Patterns</h2>

<p>You can use a “command pattern” for your command, instead of a regular expression. A command pattern is really just a short hand for a regex, and will get converted into a regex when the game starts. Here is a comparison</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  regex = "^put (?&lt;object1&gt;.*) on (?&lt;object2&gt;.*)$"
  pattern "put #object1# on #object2#"
</code></pre></div></div>

<h2 id="what-about-object-matching">What About Object Matching?</h2>

<p>None of the above has paid any attention to what objects are present in the game or are within reach. All these functions do is match text. I could have used this as the regex, the result would be the same (except the dictionary returned from <code class="highlighter-rouge">Populate</code> would contain different keys of corse).</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regex = "put (?&lt;bill&gt;.*) on (?&lt;ben&gt;.*)"
</code></pre></div></div>
<p>Once a command has been selected as the best match, it is only <em>then</em> that Quest will attempt to match the text to the objects present. At this point it will complain if we use “bill” and “ben”; all capture group names <em>in commands</em> must start “object”, “exit” or “text”, so Quest knows what it is supposed to be matching them to.</p>

<h2 id="text-matching">Text matching</h2>

<p>Text will match anything, and so is useful if you want to relate a command to an object outside the normal scope. You could also use text matching for open-ended commands, such as SAY, as is done in the basic tutorial. You then need to work out what you will do with the text.</p>

<p>You can limit the text that will be matched. In the following example, a cheat command is set up; the player (presumably the author while testing) can type CHEAT followed by either MOVE, SET or GET, followed by further text. Quest will hand two variables to the command’s script, <code class="highlighter-rouge">text1</code> and <code class="highlighter-rouge">text2</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>^cheat (?&lt;text1&gt;move|set|get) (?&lt;text2&gt;.+)$
</code></pre></div></div>

<p>Here is another example that would allow you to handle violent commands peacefully:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>^(?&lt;text&gt;hit|strike|slap|punch|kick|headbutt|kill|murder) (?&lt;object&gt;.+)$
</code></pre></div></div>

<p>If the player types KICK BORIS, Quest will match it to this command, putting “KICK” in the <code class="highlighter-rouge">text</code> variable, the object <code class="highlighter-rouge">Boris</code> in the <code class="highlighter-rouge">object</code> variable, so you could have have a message like this:</p>

<blockquote>
  <p>“For a moment you want to “ + LCase(text) + “ “ + object.name + “, but then you think better of it.”</p>
</blockquote>

<p>By the way, to get HIT to work, you will need to disable the built-in verb. You can do that in the desktop version only, by copying the verb into your game, and then typing a load of nonsense into the pattern. The player will never type in that nonsense, so the verb will never get matched.</p>

<h2 id="more-on-regex">More on Regex</h2>

<p>Quest is based on .Net technology, and so uses the .Net format for regex. That said, it is fairly standard and is used across several programming languages, and not at all specific to Microsoft (one difference, though, is how capture groups are defined).</p>

<p><a href="https://msdn.microsoft.com/en-us/library/az24scfc.aspx">https://msdn.microsoft.com/en-us/library/az24scfc.aspx</a></p>

<p>A lot of regex options start with a backslash, and this is a bit of a problem, because Quest is using strings to handle them, and in Quest (and most programming languages) the backslash is an escape character. What this means is that to display a backslash in Quest, you actually need to have two of them.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msg("Here is a single backslash: \\")
</code></pre></div></div>
<p>If you want to use any regex option that has a backslash <em>in your code</em> you need to remember to use two! An important use of backslashes is to match against a character that has some special meaning. For example, to match a question mark, the standard way is to use <code class="highlighter-rouge">\?</code>. In quest you will need to use <code class="highlighter-rouge">\\?</code>.</p>

<p>However, for pattern-matching <em>in a command</em>, you do not need the extra backslash.</p>

<p>So what can we put into a regular expression? There is a variety of options allowing you to specify your template as broadly or as narrowly as you want.</p>

<h3 id="classes">Classes</h3>

<p>You can match against a class of characters. For example, <code class="highlighter-rouge">\d</code> will match a single digit.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\d    Any digit
\D    Any non-digit
\w    Any word character (digit or letter)
\W    Any non-word character
\s    Any white space (space, tab, return)
\S    Anything not white space
.     Anything (except return)
</code></pre></div></div>
<p>You can also set up you own class using square backets. Some examples:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[aeiou]     Any single character in the group aeiou
[^aeiou]    Any single character NOT in the group aeiou
[a-mA-M]    Any letter from A to M, upper or lower
</code></pre></div></div>

<h3 id="quantifiers">Quantifiers</h3>

<p>You can control how many of a thing can be matched using ?, + and *. To illustrate, let us start with this:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regex = "\\d+\\.?\\d*"
</code></pre></div></div>
<p>There are three parts to it (removing the extra backslashes):</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\d+
\.?
\d*
</code></pre></div></div>
<p>The <code class="highlighter-rouge">\d</code> matches a digit. When followed by <code class="highlighter-rouge">+</code> it matches 1 or more digits, and when followed by <code class="highlighter-rouge">*</code> it matches zero or more. A <code class="highlighter-rouge">.</code> in a regex can match any character, as was seen in the capture groups of the first regex. Here, though, it is preceded by a backslash, so it instead means an actual full stop (period). The question mark after it indicates you can have zero or one of them. This regex will match a string containing a series of digits, optionally followed by a single decimal point and optionally followed by more digits.</p>

<p>You can also use curly braces to specify a specific number or range:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\d{2,5}    Between 2 and 5 digits
[aeiou]{4} Exactly 4 vowels
</code></pre></div></div>

<h3 id="anchors">Anchors</h3>

<p>Anchors allow to to specify where in the string the match must be. In the previous example, the number could be anywhere in the string. Perhaps you require them to be at the beginning or end?</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regex = "^help$"
</code></pre></div></div>
<p>The <code class="highlighter-rouge">^</code> and <code class="highlighter-rouge">$</code> are special codes that must match the start of the string and the end respectively, and they appear in most built in Quest commands. \A and \z do the same. \b must match the boundary between alphanumerics and non-alphanumerics.</p>

<h2 id="other-applications">Other Applications</h2>

<p>Here is some code that will handle a string like this:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  player.health = 60
</code></pre></div></div>
<p>It uses a regex to first confirm the string is in the right format, and then to split it into the three important parts.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>regex = "(?&lt;object&gt;.+)\\.(?&lt;attribute&gt;\\S+)\\s*=\\s*(?&lt;value&gt;.+)"
if (not IsRegexMatch(regex, text)) {
  error ("Sorry, wrong format")
}
dict = Populate(regex, text)
obj = GetObject(StringDictionaryItem(dict, "object"))
if (obj = null) {
  error ("Sorry, object not recognised")
}
att = StringDictionaryItem(dict, "attribute")
value = Eval(StringDictionaryItem(dict, "value"))
set (obj, att, value)
</code></pre></div></div>
<p>Note: <em>The web editor seems to have problems with complicated regex code, and will likely get confused and throw an error at the first line above, so this may be restricted to the desktop editor.</em></p>


      <div class="footer">
        <hr/>
        <a href="http://textadventures.co.uk/"><img src="logo.png"/></a>
      </div>
    </div>

  </body>
</html>
